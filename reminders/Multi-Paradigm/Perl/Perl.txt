# Perl #

## General and Documentation ##
perl program.pl
or ./program.pl if there is #!/usr/bin/perl on the first line
option -w to turn on warning (perl -w program.pl or #!/usr/bin/perl -w)

Doc at http://perldoc.perl.org

### Conventions ###
*   variable_name
*   CONSTANTES_NAME
*   ClassName
*   _private_variable
*   _private_method
*   packageName

## Pragma ##

```
use strict;
use warnings;
```

## Comment ##
```
# a comment
```
Annotations :
*   __TODO__: describe missing functionality that should be added at a later date
*   __FIXME__: describe broken code that must be fixed
*   __OPTIMIZE__: describe code that is inefficient and may become a bottleneck
*   __HACK__: describe the use of a questionable (or ingenious) coding practice
*   __REVIEW__: describe code that should be reviewed to confirm implementation


## I/O ##
```
print "Hello world\n";
$input = <STDIN>;
```


## Scalars ##
```
my $nb1 = 0.00001;
my $name = 'nicolas';
my $weird_number = 3.27e7;

# operations
my $sum = $nb1 + $weird_number;

# interpolation
my $price = 300;
my $offer = "The price is \$$price";

# test of definition
my $var7;
if !(defined($var7)) {print $var7;}
# won't print anything since $var7 = undef

# value types : number, string, ref, glob, undef
```


## Arrays ##
```
# arrays = ordered list of scalar values
my @fruit = (
    'apple',
    'orange',
    'guava',
    'grapes'
);
my @random_var = ('mumble', 42, $name);

# accessing elements
print $fruit[0]; # prints 'apple'

# array slices
print @fruit[0, 2]; # prints apple, guava
print @fruit[1 .. 3]; # prints orange, guava, grapes

# setting value
$fruit[4] = 'something';
$fruit[400] = 'else';
@fruit[4, 7 .. 9] = ('four', 'seven', 'eight', 'nine'); # with slices
@fruit[1, 2] = @fruit[2, 1];
($x, $y) = ($y, $x);

print $fruit[$#fruit]; #print the last element
my $count = @array; # count = nombre d'éléments du tableau

# add an element to the end/begining
push @fruit, 'kiwi';
shift @fruit, 'banana';

# remove and return the last.first element
pop @fruit;
unshift @fruit;

# sort and reverse (doesn't sort/reverse in place)
@sorted = sort @fruit;
@reverted = reverse @fruit;

# string convertion
$fruit_string = join ', ', @fruit; # apple, orange, etc.
```


## Hash ##
```
# hash = dictionnaries
my %french = (
    'one', 'un',
    two => 'deux',
    three => 'trois'
);

# accessing hash values
print $french{one}


# hash slices
print @french{'one', 'two', 'three'};

# setting values
$hash{foo} = 'bar';
@hash{'foo', 'bar'} = ('something', 'else');
@hash{'bar', 'foo'} = @hash{'yop', 'yip'};

# remove a key/value pair
delete $hash{'foo'}; # @hash{$key1, $key2} for multiple removes

# verify if an element exists in a hash
exists $hash{'foo'};

# get the list of keys
keys %hash;

# get the list of values
values %hash;
```


## Predefined Variables ##
Specific doc: http://perldoc.perl.org/perlvar.html

$_ : Default variable
```
# the equivalent of "it" in english
print; # prints the value of $_

# exemple
while (<FILE>) {
    if (/regex/) {
        print;
    }
}
```

@ARGV : array of command line arguments

%ENV : dictionnary of environment variables
```print $ENV{PATH}```

$0 : program name
$/ : input separator
$\ : output separator
$| : autoflush
$! : sys/libcall error
$@ : eval error
$$ : process ID
$. : line number
@INC : include paths
@_ : subroutine args


## Maths and Numerics ##
Operation    | Description
-------------|-------------
+ - * / % ** | add, sub, mult, div, mod, pow
+= -= etc.   | abbreviation of val = val + val2 <=> val += val2
++ --        | in/decrementation

Function        | Description
----------------|-------------
int($var)       | convert a numeric variable into an integer
abs cos sin tan | absolute and trigonometric functions
exp log sqrt    | exponentiation using e, log to base e, square root
rand            | returns a random number


## String and Regular Expression ##
Operation    | Description
-------------|-------------
.            | concatenation (string) ```'a' . $var . 'b';```
x            | repetition (string) ```$line = '-' x80;```
.= x=        | abbreviations

Function                 | Description
-------------------------|-------------
length $str              | return the length of a string
uc/lc $str               | return the uppercase or lower case version
uc/lcfirst               | same as above but just the first character
chop $str                | remove the last character of a string (in place)
chomp $str               | same as above but just if it's a new line and return true/false
substr($str, begin, end) | return the sub string with end non-inclusive.
split(/regexp/, $str)    | split the string into an array

Note : You can assign to substr to change a string :
```
my $str = "Hello World\n";
substr($str, 0, 5) = 'Greetings';
```
Split exemple :
```
my $str = '1~2~3~4~5~6~7'
my @array = split(/~/, $str);
```


## Files and Filehandle ##
Operation    | Description
-------------|-------------
<>           | Read from filehandle
-e           | existence of a file ```-e $file;```
-r           | test if the param is readable ```-r $file;```
-w           | test if the param is writeable ```-w $file;```
-d           | test if the param is a directory ```-d $file;```
-f           | test if the param is a normal file ```-f $file;```
-T           | test if the param is a text file ```-T $file;```
-B           | test if the binary is a text file ```-B $file;```

```
# open a file and associate it to a filehandle
open(my $file, '<', 'path/to/file.ext'); # read mode
open(my $file, '>', 'path/to/file.ext'); # write mode and overwrite
open(my $file, '>>', 'path/to/file.ext'); # write mode and append


# read file
$line = <$file>; # one line
@lines = <$file>; # all lines
$bytes = read($file, $buffer, $size); # put the number of bytes in size into a buffer

# move into a file
seek($file, $movement, $whence);
# whence = 0 for begining of file, 1 for current position and 2 for end of file

# get cursor position
tell $file;

# truncate file
truncate $file, $position;

# write to file
print $file "some data\n";

# close file
close($file);
```


## Time ##
