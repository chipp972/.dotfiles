# Philosophy and tips #

## Projects ##
*   On passe 3/4 du temps à lire le code pour debug et 1/4 à coder réelement
*   Lorsqu'on code une API, pour les tests, faire sous forme d'exemple d'utilisation simple et complet pour montrer l'utilisation de chaque fonction.
*   Vérifier que les multiplications sur de grands nombres sont vraies
    (3^32 *3^32 faux sur machines 32bits. Prendre le résultat et diviser par un des 2 et vérifier que c'est égale a l'autre)
*   Donner l'outil et les conditions pour les mesures de temps (machine, clock...) mesurer temps réel plutôt
*   Taille mémoire = dec etc. (taille code + taille pile + taille données statiques etc.)
    -> ("get rusage") max rss (taille occupée en mémoire a un instant donné)
*   Avec liste faire juste un tableau car chaque élément peut déjà pointer sur d'autres éléments

*   Keep it simple. Design for simplicity; add complexity only where you must.
	When a program has nothing surprising to say, it should say nothing.
	Write the code for the human that will read it and not for the computer that will execute it. A small increase in performance doesn't worth a large increase in complexity and obscurity of technique.
	Don't forget to comment what the program is intended to do. Add comments like "If you ever need to…" for extension purposes.
	Complex code is more likely to have bug than simple ones.

*   Modularity : Write simple parts connected by clean interfaces. Séparer le code par feature.
	Separate policy from mechanism <=> separate interfaces from engines.
	The only way to build complex software is to keep its global complexity down : build it out of simple parts connected by well-defined interface so that problems are local and you can upgrade each part without breaking the whole software.
	Single Responsibility principle : split by features

*   Coder pour le futur avec fichier de configuration
	Design for the future, because it will be here sooner than you think.

*   When debugging, don't guess. Use the scientific method and derive your findings from concrete data. If you don't have data go get it first.
*   Design for visibility to make inspection and debugging easier.
	When you must fail, fail noisily and as soon as possible.
	Catch les erreurs et verif retour appels syst
	Si l'erreur n'est pas grave l'indiquer simplement.
	Ne pas compenser le manque d'informations capitales pour interpréter à tout va les entrées.

*   Robustness is the child of transparency and simplicity
	Avoid handling many special cases.

*   Avoid premature optimization. Build from a plan. If it doesn't fit refactor the plan.
	Prototype before polishing. Get it working before you optimize it.
	Agile mindset.

*   Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming
	Fold knowledge into data so program logic can be stupid and robust.
	To make a software evolve, try to shift complexity from code into data structure

*   In interface design, always do the least surprising thing. Using the program should be the simplest possible

*   Programmer time is expensive; conserve it in preference to machine time.
	Avoid hand-hacking; write programs to write programs when you can.
	Use code generation to raise the level of abstraction (only if you don't have to hand hack the generated code)

### Tests ###
*   Always write tests cases ahead of coding and celebrate every bug found with a new test.
*   Test every feature and function of the project.
*   __Test Driven Development Method__ :
    1.  write a "single" unit test describing an aspect of the program
    2.  run the test, which should fail because the program lacks that feature
    3.  write "just enough" code, the simplest possible, to make the test pass
    4.  "refactor" the code until it conforms to the simplicity criteria
    5.  repeat, "accumulating" unit tests over time
*   Don't :
    *   forget to run tests frequently
    *   write too many tests at once
    *   write tests that are too large or coarse-grained
    *   write overly trivial tests, for instance omitting assertions
    *   write tests for trivial code, for instance accessors

## Tips ##
*   Read source code and snippets from experienced programmers to figure out best practices
*   When building a big project always finish :
    *   the Requirements Specification
	*   the Impact Analysis Document
	*   the Design Document
	*   to Document all the assumptions and limitations
	*   the review of all the documents
	*   to get sign off on all the documents from all the stakeholders
*   Find a logic to generate passwords and change them frequently

*   When documenting knowledges on a language or system, split them like this :
    *   Design Approaches
	*   Tips & Tricks
	*   Special functions, commands, instructions
	*   Lessons learnt
	*   Peculiar situations
	*   Debugging methods
	*   Best Practices, conventions and coding standards
*   Conventions include :
    *   File Naming convention
    *   Function & Module Naming convention
    *   Variable Naming convention
    *   History, Indentation, Comments
    *   Readability guidelines
    *   List of do's and don'ts
*   Check the most popular questions for the language on Stackoverflow

## Language choice ##
*   C to analyze, transform and manipulate big sets of data
*   OOP to implement black boxes (objects with their logic inside them)
*   FP to apply a transformation to some input data to produce some output leaving the data unchanged

## Unix philosophy ##
*   Write programs that do one thing and do it well.
*   Write programs to work together. Design programs to be connected to other programs (the output of one program can be the input of another)
*   Write programs to handle text streams, because that is a universal interface.
*   Write a big program only when it is clear by demonstration that nothing else will do.
	Distrust all claims for “one true way”.


## Carreer Philosophy ##
*   Try to become a software engineer : Don't tie up to a language but understand the philosophy, algorithms, data structure, Operating System mechanics behind the systems that work (Unix philosophy)
*   Clarity is better than cleverness. That's why I'd rather code in python, ruby, coffee script than in OCaml
*   Learn a new language each year (**the pragmatic programmer** from Andrew Hunt and David Thomas)
