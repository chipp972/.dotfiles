(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)       GENERALITE       (-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)

===============
FORME GENERAL :
===============

import nom.package; // importer un package


la fonction main est une méthode de type public static void d'une classe :

public maClassDeBase
{
	//parametres

	public static void main(String[] args)
	{
		//instructions
	}
}

// commentaires
/* commentaires */



===================
LA SORTIE CONSOLE :
===================

System.out.print("message console");
System.out.println("message \"console\" suivi d'un retour a la ligne");
System.out.print(variable);
System.out.print("message console " + variable); //le "+" est l'opérateur de concaténation

\n : retour à la ligne
\t : tabulation
\r : retour au chariot (retour à la ligne + début de paragraphe)



=====================
LES ENTREES CLAVIER :
=====================

import java.util.Scanner; //obligatoire pour utiliser la class Scanner

Scanner keyboardInput = new Scanner(System.in);

String chaine = keyboardInput.nextLine(); // affecte la prochaine ligne tapper en console
int a = keyboardInput.nextInt(); // affecte le prochain int tapper en console
double b = keyboardInput.nextDouble();
etc.

seule la méthode nextLine() vide le buffer (on aura le \n dans les autres cas)


===============
LES VARIABLES :
===============

-------
Types :
-------

- byte    : entiers de -127 a 128
- short   : entiers de -32768 a 32767
- int     : entiers de -2*10^9 a 2*10^9
- long    : entiers de -9*10^18 a 9*10^18
- float   : reel sur 4 octets
- double  : reel sur 8 octets
- char    : un caractere entre ''
- boolean : true ou false
- String  : class pour les chaines de caracteres

String chaine;
chaine = "Titi et gros minet";

String chaine = new String();
chaine = "Une autre chaîne de caractères";

String chaine = "Une autre chaîne";

String chaine = new String("Et une de plus ! ");

type variable1 = valeur1, variable2 = valeur2; //déclaration multiple


--------------------------------
Les méthode de la class String :
--------------------------------

char c = chaine.charAt(0); // affecte le premier caractere de la chaine

chaine.toLowerCase(); // retourne la chaine en minuscule

chaine.toUpperCase(); //retourne la chaine en majuscule

str3 = str1.concat(str3); // stock dans str3 la chaine concaténée de str1 et str2

chaine.lenght(); // renvoie la taille de la chaine

str1.equals(str2); // renvoie true ou false suivant si les chaines sont identiques

chaine2 = chaine.substring(3, 13); //renvoie la sous chaine du caractere 3 au 12e

String mot = new String("anticonstitutionnellement");
int n = 0;
n = mot.indexOf('t');      // n vaut 2
n = mot.lastIndexOf('t');        // n vaut 24


------------------------------
Les méthode de la class Math :
------------------------------

Math.random(); // renvoie un nobmre entre 0 et 1
Math.sin(angleDegree); 
Math.cos(b);
Math.tan(c);

Math.abs(nombreSigne); // renvoie la valeur absolue du nombre

Math.pow(a, b); // renvoie a^b



------------
Opérations :
------------

a = b (affectation)
a = b + c
a = b - c
a = b*c
a = b/c
a = b%c
a++
a--
a+=1
a*=2
etc.

type1 variable = valeur, variable1 = valeur;
type2 variable2 = (type2)variable/(type2)variable1; //conversion en gardant la précision du résultat
dans l'ordre : opération, cast, affectation

-- conversion en type string :
int i = 12;
String j = j.valueOf(i); // conversion int -> String
int k = Integer.valueOf(j).intValue(); // conversion String -> int
Il existe aussi floatValue(), doubleValue() etc.


------------
Conditions :
------------

==, >, <, !=, >=, <=, && (et), || (ou), ! (non)

1) if, else
-----------

if (variable < variable2)
{
	// instructions;
}
else if (variable > variable3)
{
	// instructions;
}
else
{
	// instructions;
}

2) switch
----------

switch(variable)
{
	case 0:
		instructions;
		break;
	default:
		instructions;
		break;
}

3) ternaire
------------

int x = 9, y = 10;
int max = (x > y) ? x : y/2; // x > y  ? si c'est true max = x sinon max = y/2


---------
Boucles :
---------

while(condition)
{
	instructions;
}

do
{
	instructions;
} while(condition);

for (int i(0) ; i < variable ; i++)
{
	instructions;
}

break; permet de sortir de la boucle sans effectuer le reste


==============
LES TABLEAUX :
==============

1) Généralités
--------------

type tab[] = new type[8];
type[] tab = new type[25]; //2e méthode

type tab[4][2] = {{5,6,9,15}, {80,65,41,39}}; //initialisation et affectation

int i = tab.lenght; // on affecte à i la taille du tableau


2) Parcours d'un tableau
------------------------

int tab[] = {2, 56, 9, 33, 96};
for(int i : tab)
{
	//i prend toutes les valeurs de tab
}

String tab[][] = {{"hehe", "hoho", "huhu"}, {"haha", "hyhy", "hihi"}};
for(String sousTab[] : tab)
	for(String chaine : sousTab)
	{
		//chaine prendra chacune des valeurs du tableau 2 dimensions en parcourant ligne par ligne
	}



(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)       CLASSES ET OBJETS      (-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)
(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)(-)

========================
MOTS CLE ET DEFINITION :
========================

Statique <-> à la compilation
Dynamique <-> à l’exécution
Au niveau des types : le compilateur vérifie simplement que tous les appels correspondent bien à une méthode ou une variable dans l'objet demandé.


Portée :
--------

- public : accéssible dans toutes les classes.

- private : accéssible uniquement à l'intérieur de l'objet.

- protected : accessible à l'intérieur de l'objet et dans les class dérivées (private aurait empêcher une class dérivée d'y accéder).

- static signifie que la méthode ou la variable est accéssible sans créer d'instance d'objet et est commune à tous les objets de la class (méthode/variable de class).
  (les initialisations de variable doivent avoir lieu à la compilation) (NB : ne peut pas être redéfinie mais peut être surchargée)


Types :
-------

- les variables de classes : communes à toutes les instances de la classe. Repérée par le mot clé static.

- les variables d'instances : définie les caractéristiques de l'objet. (celles qui ne sont pas static)

- les variables locales : utilisable uniqueement à l'intérieur de l'objet. (celles qui sont private)


Création :
----------
Une classe est composée de :
- champs : les données (variables)
- méthodes : les fonctions
- classes imbriquées

Modificateurs :
---------------
- public (par défaut, accéssible dans le package)
- abstract (classe incomplète, pas d'instance possible)
- final : Si c'est une class, elle ne peut pas être étendue à une class fille (pas d'héritage)
          Si c'est une méthode elle ne peut pas être redéfinie dans une class fille. 
          Si c'est une variable elle peut être occultée (redéfinie). 
- Strictfp (?)
- Annotations (?)


Déclaration :
-------------

class objet = new class(); //création d'une instance de class ou objet (et appel du constructeur de base)

class[] nom = new class[3];

if(obj instanceof class) // test si obj est une instance de la class class


===============
LES VARIABLES :
===============

Une variable est une référence à un objet de type :
- primitif (une valeur)
- référence : un objet existant ou crée par new

null : référence universelle

- Pour des variables qui font référence à des objet, 
a == b teste si a et b font référence au MEME objet (la méthode equals peut-être rédéfinis).

- Par contre pour des variables qui font référence à des types primitifs (char, int, boolean etc.),
a == b teste si les valeurs sont égales.

- Le type d'une variable est déterminé à la compilation (déclaration et portée) 
-> avec l'héritage la variable peut être une référence vers un objet d'un autre type que le type de sa déclaration



==============
LES METHODES :
==============
- La signature d'une méthode (nom + type des paramètres) est ce qui la définit. Elle doit être différent poru chaque méthode.

- On peut surcharger les méthodes c-a-d créer des méthodes de même nom 
avec un type et des paramètres différents pour gérer plusieurs cas pertinents.
ex : int f(int i) {}
int f(double f) {}

- L'association entre le nom de la méthode et sa déclaration est faite à
la compilation, mais l'association entre le nom de la méthode et sa
définition sera faite à l'exécution.

- La résolution de la surcharge a lieu à la compilation : le compilateur détermine quelle méthode utiliser en fonction du type des paramètres. 
(peut poser un problème en cas de transtypage)


La méthode main :
-----------------
Point d'accès du programme. Méthode statique donc crée à la compilation.
//dans une class
public static void main(String[] args) {}


Déclaration :
-------------
portée type nomMethode(type params){} //Création d'une méthode dans une class


public static type nomMethode(type params) //par exemple pour une méthode static dans une class
{
	//instructions
}


Constructeurs :
---------------
Méthode qui initialise un objet à sa création (avec new)
public ClassName() // constructeur par défaut. ClassName(type param1, type2 param2 etc.) pour créer un constructeur surchargé ensuite
{
	// instructions, initilisation des parametres
}


Accesseurs et mutateur :
------------------------
Méthodes d'instance qui permettent de récupérer ou de modifier les variables d'un objet (car celles-ci sont privées ou protected en général).
public String getNom(){ return nom; } // par exemple pour obtenir la variable "nom" de l'objet.
public void setNom(String nom){ this.nom = nom; } // pour modifier la variable "nom" à partir d'une String donnée en paramètre


==========
HERITAGE :
==========
- Une class peut hériter que d'une seule class mère (pas d'héritage multiple) mais peut être étendue à une infinité de class filles.
- Si B est une extension de A alors B est un A avec des propriétés supplémentaires (variables et méthodes).
- Toutes les class héritent de la class Object.

Utilisation :
-------------
Class B exends A {}

Redéfinition de variable :
--------------------------
On peut redéfinir une variable dans une class fille. La variable de la class mère existe toujours mais est cachée. 
Il faut utiliser super.var pour y accéder (ou plutôt utiliser l'accésseur)

-------------------------
Redéfinition de méthode :
-------------------------
- On peut redéfinir une méthode héritée d'une class parent en la réécrivant dans la class enfant.
- On peut la surcharger en changeant la signature de la méthode mais en gardant le nom.
- On peut utiliser l'instruction "super.methode();" pour obtenir le traitement de la class parent dans la méthode puis rajouter des choses.
- L'instruction "super();" appel le constructeur de la class de base et "this();" appel le constructeur de la class elle même.
- Si aucun constructeur n'est défini dans une classe fille, la JVM en créera un et appellera automatiquement le constructeur de la classe mère.
- Une méthode (re)définie dans une class ne peut être évalué que dans le contexte des variables définie dans cette class.
- Une méthode redéfinie ne peut qu'augmenter le controle d'accès (de private à protected ou public)


Méthodes abstraites :
---------------------
Une méthode abstraite ne peut être définie que dans une class abstraite.
Elle est crée en mettant l'en-tête de la méthode suivis d'un ";". C'est une méthode vide.
ex : abstract void manger();


Méthodes de la class Object :
-----------------------------
- public final Class<? extends Object> getClass() : retourne "class <nom de la class>"
- public int hashCode()
- public boolean equals(Object obj)
- protected Object clone() throws CloneNotSupportedException
- public String toString()
- protected void finalize() throws Throwable (wait, notify,notfyall)


equals() :
----------
Méthode qui définit lorsque deux objets de la class sont égaux (la comparaison avec "==")
//dans la class
public boolean equals(Object o){
	if (o instanceof B)
	return i==((B)o).i && j==((B)o).j;
	else return false;
}


toString() :
------------
Méthode qui permet de définir la chaine de caractere afficher lorsqu'on essaye d'afficher notre objet dans la sortie standard 
(de base on utilise la méthode de la classe Object)

// dans la class
public String toString(){
	return getNom(); //on renvoie la valeur de de la méthode this.getNom() par exemple
}

//dans le main
System.out.println(obj); qui revient à écrire System.out.prinln(obj.toString());



Destruction :
-------------
Un objet est détruit lorsqu'il n'a plus de référence.
On peut exécuter du code quand un objet est détruit en ajoutant la méthode :
protected void finalize() throws Throwable


-------------------------
Upcasting & Downcasting :
-------------------------
- L’upcasting permet de considérer un objet d'une classe dérivée comme un objet d'une classe de base.
(il ne s'agit pas réellement d'une conversion : l'objet n'est pas modifié)
L'upcasting peut être implicite : il est sans risque !

- downcasting: affirme que l'objet considéré est d'un type plus spécifique que le type correspondant à sa déclaration.
Il faut dans ce cas un cast (transtypage) explicite (la "conversion" n'est pas toujours possible : l'objet référencé peut ne pas être d'un type dérivé)
Le cast est vérifié à l'exécution. L'objet n'est ici encore pas modifié mais le cast est obligatoire.


===============
POLYMORPHISME :
===============
- Permet d'utiliser des objets sans connaître par avance leur type.
- Notion particulièrement intéréssante si on utilise des class and des méthodes redéfinis (et non surchargées).

Covariance des variables :
--------------------------
Une "variable objet" peut faire référence à un objet d'une class qui hérite de la class de la variable.
ex : si B extends A, on peut écrire "A var = new B();". 


============
INTERFACES :
============
Une interface est composée de :
- constantes (toutes les variables déclarées sont static public et final)
- méthodes (elles sont implicitement abstract)
- classes internes et d'interfaces

Une interface peut être étendu à d'autres interfaces.
ex : public interface SerializableRunnable extends Serializable, Runnable{}

Déclaration :
-------------
public interface I{ 
	public void C();
	public String D(); 
}


Utilisation :
-------------
Class A implements I, I1 { // la classe A implémente les interfaces I et I1
	public void C(){} // on est obligé de redéfinir les méhodes de l'interfaces
	public String D(){} //idem
	public int E(){} // méthode de l'interface I1 par exemple
} 
Le polymorphisme nous permet de définir ensuite :
I var = new A();
I1 var2 = new A();
var.C();
var2.E();

Class B extends A implements I, I1{ // méthodes de I et I1}


Autres Interfaces :
-------------------
- Cloneable: est une interface vide un objet qui l'implémente peut redéfinir la méthode clone
- Comparable: est une interface qui permet de comparer les éléments (méthode compareTo)
- runnable: permet de définir des "threads"
- Serializable: un objet qui l'implémente peut être "sérialisé" = converti en une suite d'octets pour être sauvegardé.

Clonage :
---------
- la méthode clone() retourne un objet dont la valeur initiale est une copie de l'objet (car l'affectation de base ne modifie pas l'objet mais y fait juste référence)
- on doit implémenter l'interface Cloneable pour pouvoir utiliser la méthode clone() de Object Sinon la méthode lance une exception "CloneNotSupportedException"
- la méthode clone est protected donc elle ne peut être utilisée que dans les méthodes définies dans la classe ou ses descendantes (ou dans le même package).

-> en implémentant Cloneable, Object.clone() est possible pour la classe et les classes descendantes
- Si CloneNotSupportedException est captée, le clonage est possible pour la classe et les descendants
- Si on laisse passer CloneNotSupportedException, le clonage peut être possible pour la classe (et les descendants) 
(exemple dans une collection le clonage sera possible si les éléments de la collection le sont)

-> en n'implémentant pas Cloneable, Object.clone() lance uniquement l’exception, 
en définissant une méthode clone qui lance une CloneNotSupportedException, le clonage n'est plus possible.


====================
CLASSES IMBRIQUEES :
====================
Une classe imbriquée peut être :
- une classe membre statique : membre statique d'une autre class
- une classe membre ou classe interne (inner class) : membre d'une classe englobante
- une Classes locales : classes définies dans un bloc de code
- une Classe anonyme : class locale sans nom


- un objet Interne (ou d'une de ses extensions) n'a de sens qu'à l'intérieur d'un objet Externe)


============
EXCEPTIONS :
============
try {
	// code à tester
} catch (nomException e) {// traitement de l'exception}
finally {//code effectué dans tous les cas}
}

============
GENERICITE :
============
