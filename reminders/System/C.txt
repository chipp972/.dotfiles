# C #

*   vfork() plus adapté pour faire un exec vu qu'on ne copie pas l'env tout de suite
*   Fork() seulement avec MMU (hardware)
*   mmap permet de réserver une taille mais de ne prendre la place que quand nécessaire. On peut donc faire tourner des programmes qui ont un besoin en mémoire théorique supérieur à notre capacité de mémoire physique.
*   Tester gcc -O1/2/3 : permet d'optimiser le code en changeant l'ordre des instructions et en optimisant les boucles (sauf sur les variables volatiles)
*   Passer des struct aux threads

## Concurrence ##
*   Toujours prendre les mutex dans le même ordre
*   Sem peut être pris par un th et débloqué par un autre. Pas mutex (bad usage)

## Convention ##
*   variableName
*   functionName
*   structName
*   CONSTANTE_NAME
*   MACRO_NAME
*   man 3 getopt to parse arguments

## I/O ##
*   use fgets to read from stdin (set number of char to read)
*   use snprintf, strncat and strncpy

## Memory Managment ##
*   pointers : ```
char *ptr = NULL;

/* ... */

void nullfree(void **pptr)
{
    void *ptr = *pptr;
    assert(ptr != NULL)
    free(ptr);
    *pptr = NULL;
}
```

## Genericity and function pointers  ##
You can cast any void* ptr to a function if you know its signature
```
int test(void *funcPtr, void *funcPtr2)
{
    int* (*castedFunction)(int, long, char*); // no () around return type
    void (*castedSecondFunction)(int, long, char*);

    // cast
    castedFunction = funcPtr;
    castedSecondFunction = funcPtr2;

    // usage
    (*castedFunction)(10, 100, "haha");
}
```

## Debug ##
*   use valgrind to debug programs and find memory leaks
